<?php

/**
 * @file i18n_extras.module
 * TODO: Enter file description here.
 */


/**
 * Implements hook_language_switch_links_alter().
 */
function i18n_extras_language_switch_links_alter(array &$links, $type, $path) {
  // Set language switcher links to langcode.
  foreach ($links as $langcode => $link) {
    $links[$langcode]['title'] = $langcode;
  }

  // Add untranslated class to non-translated nodes.
  if (preg_match('/^node\/(\d+)/', $path, $matches) && !empty($matches)) {
    $node = node_load($matches[1]);
    if (!isset($node->tnid)) {
      return;
    }
    if (!($translations = translation_node_get_translations($node->tnid))) {
      return;
    }
    $translations = array_keys($translations);
    foreach ($links as $langcode => $link) {
      if (!in_array($langcode, $translations)) {
        $links[$langcode]['attributes']['class'][] = 'locale-untranslated';
      }
    }
  }
}

/**
 * Implements hook_entity_query_alter().
 *
 * Limit entityreference to nodes of same language as parent node.
 *
 * @see http://drupal.org/node/1462766
 */
function i18n_extras_entity_query_alter($query) {
  if (in_array('entityreference', $query->tags)) {
    $langcode = NULL;
    // AJAX callback: entityreference/autocomplete/tags/field_related/node/faq/7371/test
    if (arg(0) == 'entityreference') {
      if (($nid = arg(6)) && is_numeric($nid)) {
        $node = node_load($nid);
        $langcode = $node->language;
      }
    }
    else {
      $lang = i18n_node_i18n_context_language();
      if (!empty($lang->language)) {
        $langcode = $lang->language;
      }
    }
    if (!empty($langcode)) {
      $query->propertyCondition('language', $langcode);
    }
  }
}

/**
 * Implements hook_field_info_alter().
 *
 * Display terms in correct language on node forms.
 *
 * @see title_taxonomy_info_alter().
 * @see i18n_extras_install() for proper description.
 */
function i18n_extras_field_info_alter(&$info) {
  if (module_exists('title')) {
    $supported_types = array('taxonomy_term_reference' => TRUE);
    foreach ($info as $field_type => &$field_type_info) {
      if (isset($supported_types[$field_type])) {
        if (!isset($field_type_info['settings'])) {
          $field_type_info['settings'] = array();
        }
        $field_type_info['settings']['options_list_callback'] = 'i18n_extras_taxonomy_allowed_values';
      }
    }
  }
}

/**
 * Implements hook_field_storage_details_alter().
 */
function i18n_extras_field_storage_details_alter(&$details, &$field) {
  if (module_exists('title') && $field['type'] == 'taxonomy_term_reference') {
    $field['settings']['options_list_callback'] = 'i18n_extras_taxonomy_allowed_values';
  }
}

/**
 * Implements hook_taxonomy_field_prepare_translation().
 */
function i18n_extras_taxonomy_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &$items, $source_entity, $source_langcode) {
  foreach ($items as $index => $item) {
    $field['settings']['options_list_callback'] = 'i18n_extras_taxonomy_allowed_values';
  }
}

/**
 * Return taxonomy term values for taxonomy reference fields.
 * Instead of using the name property use the entity_label function so that
 * names will be translated.
 */
function i18n_extras_taxonomy_allowed_values($field) {
  $bundle = !empty($field['settings']['allowed_values'][0]['vocabulary']) ? $field['settings']['allowed_values'][0]['vocabulary'] : NULL;
  if ($bundle && ($label = title_field_replacement_get_label_field('taxonomy_term', $bundle))) {
    $options = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      $vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary']);
      if ($vocabulary && ($terms = taxonomy_get_tree($vocabulary->vid, $tree['parent'], NULL, TRUE))) {
        foreach ($terms as $term) {
          // Use entity_label() instead of $term->name.
          $options[$term->tid] = str_repeat('-', $term->depth) . entity_label('taxonomy_term', $term);
        }
      }
    }
    return $options;
  }
  if (module_exists('i18n_taxonomy')) {
    return i18n_taxonomy_allowed_values($field);
  }
  else {
    return taxonomy_allowed_values($field);
  }
}
