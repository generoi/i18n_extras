<?php

/**
 * @file i18n_extras.module
 * TODO: Enter file description here.
 */

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Enable WYSIWYG on string translation pages
 * @see http://drupal.org/node/1252144
 */
function i18n_extras_form_i18n_string_translate_page_form_alter(&$form, &$form_state) {
  foreach ($form['strings']['all'] as $name => $field) {
    if (preg_match('/blocks:block:[0-9]+:body/i', $name)) {
      // Change textarea to text_format
      $form['strings']['all'][$name]['#type'] = 'text_format';
      $form['strings']['all'][$name]['#description'] = '<br/>';
    }
  }
  $form['#submit'] = array_merge(array(
    'i18n_extras_string_translate_page_form_submit'
  ), $form['#submit']);
}

/**
 * Implements hook_s_string_translate_page_form_submit().
 *
 * @see i18n_extras_form_i18n_string_translate_page_form_alter().
 */
function i18n_extras_string_translate_page_form_submit($form, &$form_state) {
  //Remove wysiwyg format because i18n cant handle it
  foreach ($form_state['values']['strings'] as $name => $field) {
    if (preg_match('/blocks:block:[0-9]+:body/i',$name)) {
      unset($form_state['values']['strings'][$name]['format']);
    }
  }
}

/**
 * Implements hook_language_switch_links_alter().
 */
function i18n_extras_language_switch_links_alter(array &$links, $type, $path) {
  // Set language switcher links to langcode.
  foreach ($links as $langcode => $link) {
    $links[$langcode]['title'] = $langcode;
  }

  // Add untranslated class to non-translated nodes.
  if (preg_match('/^node\/(\d+)/', $path, $matches) && !empty($matches)) {
    $node = node_load($matches[1]);
    if (!isset($node->tnid)) {
      return;
    }
    if (!($translations = translation_node_get_translations($node->tnid))) {
      return;
    }
    $translations = array_keys($translations);
    foreach ($links as $langcode => $link) {
      if (!in_array($langcode, $translations)) {
        $links[$langcode]['attributes']['class'][] = 'locale-untranslated';
      }
    }
  }
}

/**
 * Implements hook_field_info_alter().
 *
 * Display terms in correct language on node forms.
 *
 * @see title_taxonomy_info_alter().
 * @see i18n_extras_install() for proper description.
 */
function i18n_extras_field_info_alter(&$info) {
  if (module_exists('title')) {
    $supported_types = array('taxonomy_term_reference' => TRUE);
    foreach ($info as $field_type => &$field_type_info) {
      if (isset($supported_types[$field_type])) {
        if (!isset($field_type_info['settings'])) {
          $field_type_info['settings'] = array();
        }
        $field_type_info['settings']['options_list_callback'] = 'i18n_extras_taxonomy_allowed_values';
      }
    }
  }
}

/**
 * Implements hook_field_storage_details_alter().
 */
function i18n_extras_field_storage_details_alter(&$details, &$field) {
  if (module_exists('title') && $field['type'] == 'taxonomy_term_reference') {
    $field['settings']['options_list_callback'] = 'i18n_extras_taxonomy_allowed_values';
  }
}

/**
 * Implements hook_taxonomy_field_prepare_translation().
 */
function i18n_extras_taxonomy_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &$items, $source_entity, $source_langcode) {
  foreach ($items as $index => $item) {
    $field['settings']['options_list_callback'] = 'i18n_extras_taxonomy_allowed_values';
  }
}

/**
 * Return taxonomy term values for taxonomy reference fields.
 * Instead of using the name property use the entity_label function so that
 * names will be translated.
 */
function i18n_extras_taxonomy_allowed_values($field) {
  $bundle = !empty($field['settings']['allowed_values'][0]['vocabulary']) ? $field['settings']['allowed_values'][0]['vocabulary'] : NULL;
  if ($bundle && ($label = title_field_replacement_get_label_field('taxonomy_term', $bundle))) {
    $options = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      $vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary']);
      if ($vocabulary && ($terms = taxonomy_get_tree($vocabulary->vid, $tree['parent'], NULL, TRUE))) {
        foreach ($terms as $term) {
          // Use entity_label() instead of $term->name.
          $options[$term->tid] = str_repeat('-', $term->depth) . entity_label('taxonomy_term', $term);
        }
      }
    }
    return $options;
  }
  // i18n_taxonomy_allowed_values() simply localizes, we want the actual.
  if (module_exists('i18n_taxonomy')) {
    $options = array();
    // Node language on edit
    $node_language = i18n_node_i18n_context_language();
    // Node add form fallback to the page language.
    if (!isset($node_language)) {
      global $language;
      $node_language = $language;
    }

    foreach ($field['settings']['allowed_values'] as $tree) {
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
        switch ($vocabulary->i18n_mode) {
          case I18N_MODE_NONE:
            $options += taxonomy_allowed_values($field);
            break;
          case I18N_MODE_LOCALIZE:
          case I18N_MODE_LANGUAGE:
            $options += i18n_taxonomy_allowed_values($field);
            break;
          case I18N_MODE_TRANSLATE:
          case I18N_MODE_MULTIPLE:
            if ($terms = i18n_taxonomy_get_tree($vocabulary->vid, $node_language->language, $tree['parent'])) {
              foreach ($terms as $term) {
                $options[$term->tid] = str_repeat('-', $term->depth) . i18n_taxonomy_term_name($term);
              }
            }
            break;
        }
      }
    }
    return $options;
  }

  return taxonomy_allowed_values($field);
}
